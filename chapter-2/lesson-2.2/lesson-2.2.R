#### Функции ####

# функция для вычисления логарифма
log(8)

# логарифм всегда вычисляется по основанию, 
# поэтому на самом деле функция логарифма принимает два аргументf
log(8,2)

# Для наглядности следует указать названия аргументов. 
# В данном случае аргумент base задает основание алгоритма. 
# Он является необязательным, и его можно не указывать.
log(x = 8, base = 2)

# Чтобы открыть справку по функции достаточно 
# написать знак вопроса перед ее названием.
?log

# если явно задать названия аргументов, их порядок может быть любым
log(x = 8, base = 2)
log(base = 2, x = 8)


# Функции можно создавать самостоятельно

weight <- 75
height <- 1.70
weight / (height ^ 2)

# Создание функции расчета индекса массы тела.
calcIMT <- function(weight, height) {
  res <- weight / (height ^ 2)
  return (res)
}

# В качестве аргументов функции можно передавать как значения
aaa <- calcIMT(75, 1.70)
aaa

# Так и переменные
calcIMT(weight, height)

# Функции можно вкладывать друг в друга, 
# передавая результат выполнения одной функции в аргументы другой.
calcIMT(min(75,76,77), max(1.68,1.69,1.70))

# Функции можно загружать из внешних файлов
source("functions.R")
birthdate <- as.Date("2015-07-01")
day <- as.Date("2021-06-14")
calcAge(birthdate, day)


#### Пакеты #### 

# Список установленных пакетов.
installed.packages()

# Установка пакета.
install.packages("binom")

# Установка пакета при необходимости
if (!require(dplyr))
  install.packages("dplyr")

# Использование пакета.
library(binom)

# Установка набора пакетов.
install.packages("tidyverse")

# Подключение набора пакетов.
library("tidyverse")

#### Структуры данных ####

# Переменные могут содержать не только числа, но и последовательности чисел.
a <- 5
a
a <- c(4,8,15,16,23,42)
a

##### Вектор #####

# числовой вектор
a <- c(4,8,15,16,23,42)
a

# текстовый вектор
b <- c("one", "two", "three")
b

# логический вектор
c <- c(TRUE, TRUE, TRUE, FALSE, TRUE, FALSE)
c

# Вектора - последовательности элементов одного типа
# Последовательность можно задавать перечислением
e <- c("a","bb","ccc","dddd","eeeee")
e

# Последовательность можно задавать диапазоном значений
d <- 1:5
d

dd <- 5:1
dd

# Можно задать и определенный шаг
# Вектор от 10 до 100 с шагом 10.
dd <- seq(10,100, by = 10)
dd

# Вектор от 1 до 13, состоящий из 4 элементов.
dd <- seq(1,13, length.out = 4)
dd

# Вектор из 10 повторений символа А.
aaa <- rep("A", 10)
aaa

# Новый вектор из трехкратного повторения вектора от 1 до 3 с шагом 1.
aaa <- rep(1:3, 3)
aaa

# 1 повторить один раз, 2 - два раза, 3 - три раза.
rep(1:3, 1:3)
# Если длина векторов не совпадает, возникнет ошибка.
rep(1:3, 1:5)


# Можно повторять каждый элемент вектора
aaa <- rep(1:3, each = 4)
aaa
# Можно ограничить длину вектора повторений
aaa <- rep(1:3, length = 7)
aaa


# Объединение двух векторов.
a <- c(1,2,3)
b <- c(4,5,6)
c <- c(a,b)

# Добавление элемента в конец.
d <- c(c,9)
d

# Добавление элемента в начало.
e <- c(9,c)
e

# С векторами можно производить такие такие же операции как и с числами
# В результате действие будет выполнено над каждым элементом вектора
a
a * 5
as.character(a)

# Можно проводить арифметические операции с двумя векторами, если они одинаковой длины
a <- 1:10
a
b <- rep(5:1,2)
b
c <- a - b
c

# Если длина будет разной, то короткий вектор будет повторяться до тех пор,
# пока не сравняется по длине с длинным
a <- 1:10
a
b <- 5:1
b
c <- a - b
c
c <- b - a
c

# Длина вектора.
length(с)


# Можно обратиться к конкретному элементу вектора
a
# По позиции элемента
a[2]
# Перечисление позиций элементов
a[c(1,2,3)]
# К диапазону элементов
a[1:3]
# Если обратится за границы вектора, получим NA
a[25]
# Можно и менять значения элементов вектора
a[2] <- 8

# Найти позицию числа 6 в векторе a.
match(6,a)
# Числа 66 в векторе a нет.
match(66,a)

# Если индекс отрицательный, то в результате получим все значения вектора,
# кроме соответствующего индекса
a[-2]

# Можно обратиться к одному или нескольким элементам вектора по условию
a > 7
# Выбор четных элементов вектора.
a[a %% 2 == 0]

# Формирование вектора от 1 до 100 с шагом 10.
a <- seq(1,100, by = 10)
# Выбор элементов больше 10, но меньше 30.
a[a > 10 & a < 30]

# Создание маски для выбора элементов.
# В этом случае отберутся только те элементы, на позиции которых стоит TRUE
more_10_less_30 <- a > 10 & a < 30
more_10_less_30
values <- a[more_10_less_30]
values

# Для векторов чисел можно применять агрегирующие функции
v1 <- 1:100
mean_v1  <- mean(v1)
mean_v1

# Можно объединять векторы
v1 <- 1:10
v2 <- 24:15
v3 <- c(v1, v2)
v3
# и узнавать длину (количество элементов) вектора
length(v3)


# Существует возможность делать именованные вектора
named_vector <- c(uno = 1, dos = 2, "universal answer" = 42)
named_vector
# И обращаться к элементам по именам
named_vector["uno"]
named_vector["uno"]
named_vector[["uno"]]

# Чтобы вернуться к обычным векторам и значениям можно использовать фукнцию unname()
unname(named_vector["uno"])
unname(named_vector)


# Для числовых векторов можно применять агрегирующие функции

# Найти среднее арифметическое для значений вектора.
v1 <- 1:100
mean_v1  <- mean(v1)
mean_v1

# Наибольшее число
max(v1)
# Наименьшее число
min(v1)
# Сумма
sum(v1)

# Можно сортировать значения в векторе
v <- c(56, 25, 1, 0 , 47, 23)
t <- c("r", "a", "b", "x", "y", "c", "y")
a <- c("Иван","Петр","Аня","Сергей","Катя","Иван")
# В прямом порядке
sort(v)
# В обратном порядке
sort(t, decreasing = TRUE)

# Можно выбирать только уникальные значения в векторе
unique(a)
# И смотреть метрики для числовых векторов
summary(v)


##### Матрица #####

# Можно указать количество столбцов и строк.
y <- matrix(1:20, nrow=5, ncol=4)
y

# Можно указать только количество строк.
y <- matrix(1:20, nrow=5)
y

# Можно указать только количество столбцов.
y <- matrix(1:20, ncol=4)
y

# Элемент из первой строки первого столбца. 
y[1,1]
# Элемент из второй строки третьего столбца.
y[2,3]
# Элементы со второго по четвертый из первой строки.
y[1, 2:4]
# Первый столбец.
y[1:5, 1]
# Центр матрицы.
y[2:4, 2:3]
# Первая строка.
y[1, ]
# Первый столбец.
y[, 1]

# Умножение на 2 всех элементов матрицы.
y * 2

# Уже созданную матрицу можно полностью заполнить одним значением
y[] <- 0
y

# Заполнение матрицы по строкам
# Вектор значений
cells <- c(1,26,24,68, 55, 12, 3, 0, 14)
cells

# Имена строк
rnames <- c("R1", "R2", "R3")
rnames

# Имена столбцов
cnames <- c("C1", "C2", "C3")
cnames

m <- matrix(
  cells, nrow=3, ncol=3,
  byrow=TRUE,
  dimnames=list(rnames, cnames)
)
m

# Заполнение матрицы по столбцам
m <- matrix(cells,
                   nrow=3, ncol=3,
                   byrow=FALSE,
                   dimnames=list(rnames, cnames)
)
m

# Обращение к элементу по имени.
m["R1", "C1"]

# Для матриц можно считать агрегирующие функции так же как для векторов
y <- matrix(1:25, nrow=5, ncol=5)
sum(y)
min(y)
max(y)
mean(y)


##### Массив #####

# Массивы данных (array) сходны с матрицами, но могут иметь больше двух измерений.
dim1 <- c('A1', 'A2')
dim2 <- c('B1', 'B2', 'B3')
dim3 <- c('C1', 'C2', 'C3', 'C4')
a <- array(1:24, c(2, 3, 4), dimnames=list(dim1, dim2, dim3))
a

# Чтобы обратиться к элементу массива необходимо указывать координаты всех измерений

# Одиночный элемент
a[1,2,3]

# Слои
a[,2,3]
a[1, ,3]
a[1,2,]

# Агрегирующие функции также доступны для массивов.
sum(a)
min(a)
max(a)
mean(a)


##### Список #####

# Текстовая переменная
g <- "My First List"
# Числовой вектор
h <- c(25, 26, 18, 39)
# Матрица
j <- matrix(1:10, nrow=5)
# Строковый вектор
k <- c("one", "two", "three")
# Список может объединять элементы разных типов
l <- list(title=g, ages=h, j, k)
l

str(l)

# Можно обозначать элементы списка, указав их номер или название внутри
# двойных квадратных скобок.
l[[2]]
l[["ages"]]

##### Таблицы (data.frame) #####

# Создание таблицы из векторов.
t <- data.frame(
  c(1, 2, 3, 4),
  c(25, 34, 28, 52),
  c("Type1", "Type2", "Type1", "Type1"),
  c("Poor", "Improved", "Excellent", "Poor"))

# Присвоение имен для столбцов.
names(t) <- c("patientID", "age", "diabetes", "status")
t

# Можно сказать, что таблица это именованный список векторов.
patientID <- c(1, 2, 3, 4)
age <- c(25, 34, 28, 52)
diabetes <- c("Type1", "Type2", "Type1", "Type1")
status <- c("Poor", "Improved", "Excellent", "Poor")
t <- data.frame(patientID, age, diabetes, status)
t

# Структура таблицы
str(t)

# Можно выбирать столбцы как по номеру
t[1:2]

# Можно выбирать столбцы по названию
t[c("diabetes", "status")]

# Можно выбрать один столбец
t$age
t[["age"]]

# Можно выбрать одно значение
t$age[2]

# Можно выбрать несколько значений строки, как и в матрицах
t[1:2,2]
t[1:2,"age"]

# Можно выбирать строки по условию
t[t$age < 35, ]
# Можно выбирать строки по условию и только конкретный столбец.
t[t$age < 35, ]$diabetes
# Можно выбирать строки по условию и только несколько столбцов.
t[t$age < 35, c("patientID", "diabetes") ]

# Функция subset позволяет сделать то же самое, но запись будет компактнее.
subset(t, age < 35)
subset(t, age < 35, c("patientID", "diabetes"))


# Добавление столбца
t
t$sex <- "unknown"
t
t$sex <- c("male", "female", "male", "female")
t

# Удаление столбца
# Заполнение пустыми значениями
t$sex <- NA
t
# Удаление столбца из датафрейма
t$sex <- NULL
t


# Создание новой таблицы.
patientID <- c(1, 2, 3, 4)
age <- c(25, 34, 28, 52)
diabetes <- c("Type1", "Type2", "Type1", "Type1")
status <- c("Poor", "Improved", "Excellent", "Poor")
birthdate <- c("1997-06-05", "1988-03-25", "1994-03-08", "1970-01-01")
tt <- data.frame(patientID, age, diabetes, status, birthdate)
tt
str(tt)

# Преобразование столбца с датой рождения из строки в дату.
tt$birthdate <- as.Date(tt$birthdate)
str(tt)


# Можно менять типы столбцов прямо в датафрейме
t$birthdate <- c("1997-06-05", "1988-03-25", "1994-03-08", "1970-01-01")
str(t)
t$birthdate <- as.Date(t$birthdate)
str(t)

# Добавление строк можно делать с помощью функции rbind.
total <- rbind(t, tt)

# Но только между теми датафреймами, столбцы которых совпадают.
tt$birthdate <- NULL
total <- rbind(t, tt)
total


# Добавление строк можно делать столько между теми датафреймами, столбцы которых совпадают
total <- rbind(t, patients)
patients$birthdate <- NULL
total <- rbind(t, patients)
total

# Добавление столбцов выполняется с помощью функции cbind
total2 <- cbind(t, tt)
total2



##### Таблицы (tibble) #####

# Для использования tibble необходимо установить пакеты tidyverse
install.packages("tidyverse")
# Если не требуются все пакеты из семейства tidyverse, то можно установить только пакет tibble
install.packages("tibble")

# Загружаем пакеты
library("tibble")
library("tidyverse")

# Создаем tibble
tb <- tibble(
  patientID = c(1, 2, 3, 4),
  age = c(25, 34, 28, 52),
  diabetes = c("Type1", "Type2", "Type1", "Type1"),
  status = c("Poor", "Improved", "Excellent", "Poor"))
str(tb)
tb

# Можно преобразовывать tibble в data.frame и обратно
tbdf <- as.data.frame(tb)
str(tbdf)

tb <- as_tibble(tbdf)
str(tb)

# Есть функция для проверки является ли таблица типом tibble
is_tibble(tb)

# С tibble можно работать также как и с data.frame
# Обращаться к столбцам
tb$patientID

# Выделать поднаборы данных
pat_new <- subset(tb, age < 35)
pat_new

# Объединять строки
rbind(tb, pat_new)

##### Отличие tibble от data.frame #####

###### data.frame выводится в консоль полностью, a tibble - нет ######

df <- iris
class(df)
df

tib <- as_tibble(df)
tib

print(as_tibble(tib), n = 100)
print(as_tibble(tib), n = Inf)

###### При обращении к отдельному столбцу таблицы в результате возвращается ######

df[, "Species"] # Вектор

tib[,"Species"] # Tibble

# Но если обращаться по другому, то результат идентичен
df$Species
tib$Species

df[["Species"]]
tib[["Species"]]

###### При добавлении нового столбца ######

tib <- tibble(str = c("a","b","c","d"), int = c(1,2,3,4))
tib

df <- data.frame(str = c("a","b","c","d"), int = c(1,2,3,4))
df

# tibble - Нужно указывать вектор нужной длины (столько элементов, сколько строк в таблице)
tib$newcol <- c(5,6)
# Проверим сколько строк
nrow(tib)
# Продублируем вектор
tib$newcol <- rep(c(5,6),2)
tib

# data.frame - он продублируется автоматически
df$newcol <- c(5,6)
df



###### Арифметические операции ######

# tibble - автоматически превращается в data.frame
tib <- tibble(a = c(1,2,3), b = c(4,5,6), c = c(7,8,9))
tib
is_tibble(tib)
tib <- tib*2
is_tibble(tib)
is.data.frame(tib)

# data.frame остается data.frame
df <- data.frame(a = c(1,2,3), b = c(4,5,6), c = c(7,8,9))
is.data.frame(df)
df <- df*2
is.data.frame(df)


#### Встроенные наборы данных ####

# Посмотреть все доступные наборы
help(package = 'datasets')
help(package = 'dplyr')
help(package = 'base')

# Motor Trend Car Road Tests
str(mtcars)
# Edgar Anderson's Iris Data
str(iris)

data <- iris

# Monthly Deaths from Lung Diseases in the UK
mdeaths # males
fdeaths # females
ldeaths # both sexes

# Pharmacokinetics of Indomethacin and Theophylline
Indometh
Theoph

# Infertility after Spontaneous and Induced Abortion
infert

# Smoking, Alcohol and (O)esophageal Cancer
str(esoph)

##### Функции для оценки содержимого наборов данных #####

# Показать полное содержимое
iris
# Открыть во встроенном просмотрщике RStudio
View(iris)

# Количество строк
nrow(iris)
# Количество столбцов
ncol(iris)

# Имена столбцов
colnames(iris)
# Имена строк
rownames(iris)
rownames(mtcars)
data <- mtcars

# Показать первые 6 строк
head(iris)
tail(iris)
# Оценить структуру набора
str(iris)
# Оценить суммарные метрики набора
summary(iris)

# Для оценки характеристик числовых векторов/столбцов таблиц можно использовать встроенные статистические функции. 
# Оператор $ позволяет обратиться к одному столбцу набора данных.
iris$Sepal.Length

# Сумма всех значений.
sum(iris$Sepal.Width)

# Минимум и максимум.
min(iris$Sepal.Length)
max(1,2,3,4,5,6,7,8,9)

# Среднее арифметическое.
mean(iris$Sepal.Width)
mean(values, na.rm = TRUE)

# Медиана.
median(iris$Sepal.Width)

# Стандартное отклонение.
sd(iris$Sepal.Width)

# Квантили / Процентиль / квартиль.
quantile(iris$Sepal.Width)

# Можно скомбинировать все значения, 
# получаемые этими функциями и вывести в одну строку.

x <- iris$Sepal.Width
N <- length(x)
AVG <- round((mean(x)), 2)
SD <- round((sd(x)), 2)
AVGSD <- paste0(AVG, (paste0(" \u00B1 ", SD)))
Me <- round((median(x)), 2)
Q1 <- round((quantile(x, c(0.25))), 2)
Q3 <- round((quantile(x, c(0.75))), 2)
MeQ1Q3 <- paste0(Me, paste0(" ", "(", Q1, "; ", Q3, ")"))
Min <- round((min(x)), 2)
Max <- round((max(x)), 2)

# Вывод результата в одну строку.
paste("N =",N,",",
      "AVGSD:", AVGSD ,",",
      "MeQ1Q3:", MeQ1Q3,",",
      "Min:", Min,",",
      "Max:", Max,
      sep = " ")


#### Другие наборы данных ####

# https://github.com/higgi13425/medicaldata
install.packages("medicaldata")
library(medicaldata)
data(package = "medicaldata")

tbl <- medicaldata::covid_testing

# https://www.spsanderson.com/healthyR.data/index.html
install.packages("healthyR.data")

library(healthyR.data)

df <- healthyR_data

glimpse(df)

?glimpse

??glimpse

library(dplyr)

glimpse(df)

# Если название функций в разных пакетах совпадает, можно уточнить пакет
dplyr::glimpse(iris)
tibble::glimpse(iris)

# Еще больше различных наборов данных для тренировки
# https://causeweb.org/tshs/category/dataset/

#### Ветвления и условные переходы #### 

# Один вариант выбора
# Например, если условие выполняется - вызов функции print.
cat <- "Мяукает"
if (cat == "Мяукает"){
  print("Покормить кота")
}

# Если условие не выполняется - значение переменной остается неизменным.
age <- 14
status <- ""
if (age >= 18){
  status = "взрослый"
}
status

# Два варианта выбора
today <- "среда"
if (today == "среда"){
  print("слушаем лекцию")
} else {
  print("смотрим youtube")
}

age <- 33
status <- ""
if (age >= 18){
  status = "взрослый"
} else {
  status = "ребенок"
}
status

# Сокращенная форма записи
age <- 33
status <- ifelse(age >= 18, "взрослый","ребенок")
status

# Несколько вариантов выбора
light <- "красный"
if (light == "красный"){
  print("стоим")
} else if (light == "желтый") {
  print("ждем")
} else if (light == "зеленый") {
  print("идем")
} else {
  print("ждем когда загорится")
}


# Можно записывать и более сложные условия на сравнения
age <- 56
status <- ""
if (age >= 18 & age <= 44 ){
  status <- "Молодой возраст"
} else if (age >= 45 & age <= 59) {
  status = "Средний возраст"
} else if (age >= 60 & age <= 74) {
  status = "Пожилой возраст"
} else if (age >= 75 & age <= 90) {
  status = "Старческий возраст"
} else if (age > 90) {
  status = "Долголетие"
} else {
  status = "ребенок"
}
status

# При сравнении с конкретным значением можно использовать оператор switch
switch(light,
       "красный" = print("стоим"),
       "желтый" = print("ждем"),
       "зеленый" =   print("идем")
)

# Можно использовать несколько операций
switch(light,
       "красный" = { 
         res <- toupper("стоим")
         print(res)
       },
       "желтый" = print("ждем"),
       "зеленый" =   print("идем")
)

# Его также можно использовать для замены значений
action <- switch(light,
                 "красный" = "стоим",
                 "желтый" = "ждем",
                 "зеленый" = "идем",
                 defailt = "ждем когда загорится"
)
action


#### Циклы ####

# Для каждого i из вектора значений от 1 до 10 выполнить действия.
for (i in 1:10) {
  # Если i меньше 3, то переход на следующий шаг.
  if (i < 3) 
    next 
  # Вывод значения i на экран.
  print(i)
  # Если i больше или равно 5, прерывать цикл.
  if (i >= 5)
    break 
}

# while(condition) выполняет команду, пока заданное условие не перестанет быть истинным
# Переменная отвечающая за выполнение условия внутри цикла.
i <- 5
# Выполнить действие пока i больше 0.
while (i > 0) {
  print("Hello")
  # Уменьшение i.
  i <- i - 1
}

# repeat(action) выполняет команду, пока не прервется командой break
i <- 10
repeat {
  i <- i - 1
  print("Hello")
  if (i <= 5) break;
}
